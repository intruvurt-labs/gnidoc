import { z } from "zod";
import { protectedProcedure } from "../../../create-context";
import { callProvider } from "../../../../lib/providers/router";
import * as fs from "fs";
import * as path from "path";
import archiver from "archiver";
import { execSync } from "child_process";

const BuildSchema = z.object({
  prompt: z.string(),
  specifications: z.object({
    specifications: z.array(z.object({
      path: z.string(),
      outline: z.string(),
      components: z.array(z.string()).optional(),
      functions: z.array(z.string()).optional(),
      types: z.array(z.string()).optional(),
    })),
    apiEndpoints: z.array(z.any()).optional(),
    dbSchema: z.object({
      tables: z.array(z.any()),
    }).optional(),
  }),
  buildNonce: z.string(),
  plan: z.object({
    dependencies: z.object({
      runtime: z.array(z.string()),
      dev: z.array(z.string()),
    }),
  }),
});

export const buildProcedure = protectedProcedure
  .input(BuildSchema)
  .mutation(async ({ input, ctx }) => {
    const { prompt, specifications, buildNonce, plan } = input;

    if (!buildNonce.startsWith("build_")) {
      throw new Error("Invalid build nonce. Complete spec step first.");
    }

    const projectDir = path.join("/tmp", `project_${ctx.userId}_${Date.now()}`);
    fs.mkdirSync(projectDir, { recursive: true });

    console.log(`[Build] Creating project in ${projectDir}`);

    const files: { path: string; content: string }[] = [];

    for (const spec of specifications.specifications) {
      const systemPrompt = `You are a senior developer writing production code.
Generate complete, working code for this file based on the specification.
Requirements:
- Full implementation, no placeholders
- Include all imports
- Add error handling
- Type-safe (TypeScript)
- Follow best practices
- Add brief comments for complex logic

Return ONLY the code, no markdown, no explanations.`;

      const filePrompt = `File: ${spec.path}
Outline: ${spec.outline}
${spec.components ? `Components: ${spec.components.join(", ")}` : ""}
${spec.functions ? `Functions: ${spec.functions.join(", ")}` : ""}
${spec.types ? `Types: ${spec.types.join("\n")}` : ""}

Generate complete production code for this file.`;

      const result = await callProvider(
        "gpt-4o",
        filePrompt,
        systemPrompt,
        0.1,
        4096
      );

      let content = result.output
        .replace(/```typescript\n?/g, "")
        .replace(/```tsx\n?/g, "")
        .replace(/```javascript\n?/g, "")
        .replace(/```jsx\n?/g, "")
        .replace(/```json\n?/g, "")
        .replace(/```\n?/g, "")
        .trim();

      files.push({ path: spec.path, content });
    }

    for (const file of files) {
      const fullPath = path.join(projectDir, file.path);
      const dir = path.dirname(fullPath);
      fs.mkdirSync(dir, { recursive: true });
      fs.writeFileSync(fullPath, file.content, "utf-8");
      console.log(`[Build] Created ${file.path}`);
    }

    const packageJson = {
      name: "generated-app",
      version: "1.0.0",
      private: true,
      scripts: {
        dev: "next dev",
        build: "next build",
        start: "next start",
        lint: "next lint",
        test: "jest --passWithNoTests",
      },
      dependencies: Object.fromEntries(
        plan.dependencies.runtime.map(dep => {
          const [name, version] = dep.split("@");
          return [name, version || "latest"];
        })
      ),
      devDependencies: Object.fromEntries(
        plan.dependencies.dev.map(dep => {
          const [name, version] = dep.split("@");
          return [name, version || "latest"];
        })
      ),
    };

    fs.writeFileSync(
      path.join(projectDir, "package.json"),
      JSON.stringify(packageJson, null, 2)
    );

    const readme = `# Generated App

## Description
${prompt}

## Setup
\`\`\`bash
npm install
npm run dev
\`\`\`

## Build
\`\`\`bash
npm run build
\`\`\`

Generated by gnidoC terceS Multi-Model Builder
`;
    fs.writeFileSync(path.join(projectDir, "README.md"), readme);

    console.log("[Build] Installing dependencies...");
    try {
      execSync("npm install", { cwd: projectDir, stdio: "pipe" });
    } catch (error: any) {
      console.error("[Build] Install failed:", error.message);
    }

    console.log("[Build] Running lint...");
    try {
      execSync("npm run lint", { cwd: projectDir, stdio: "pipe" });
    } catch (error: any) {
      console.log("[Build] Lint warnings (non-fatal):", error.message);
    }

    console.log("[Build] Running tests...");
    try {
      execSync("npm run test", { cwd: projectDir, stdio: "pipe" });
    } catch (error: any) {
      console.log("[Build] Test warnings (non-fatal):", error.message);
    }

    console.log("[Build] Building project...");
    let buildSuccess = false;
    try {
      execSync("npm run build", { cwd: projectDir, stdio: "pipe" });
      buildSuccess = true;
    } catch (error: any) {
      console.error("[Build] Build failed:", error.message);
    }

    console.log("[Build] Creating zip archive...");
    const zipPath = path.join("/tmp", `app_${ctx.userId}_${Date.now()}.zip`);
    const output = fs.createWriteStream(zipPath);
    const archive = archiver("zip", { zlib: { level: 9 } });

    await new Promise<void>((resolve, reject) => {
      output.on("close", resolve);
      archive.on("error", reject);
      archive.pipe(output);
      archive.directory(projectDir, false);
      archive.finalize();
    });

    const zipStats = fs.statSync(zipPath);

    fs.rmSync(projectDir, { recursive: true, force: true });

    return {
      success: true,
      buildSuccess,
      zipPath,
      zipSize: zipStats.size,
      filesCreated: files.length,
      message: buildSuccess 
        ? "Project built successfully"
        : "Project created with warnings (build failed, manual fix needed)",
    };
  });
